Index: main/analysis.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from FunctionClass import Function\n\n\ndef sekanten_verfahren(f, x1, x2):\n    eps_stop = 10 ** -15\n\n    y1 = f.lam(x1)\n    y2 = f.lam(x2)\n\n    if y1 == 0:\n        return x1\n\n    elif y2 == 0:\n        return x2\n\n    elif y1 * y2 > 0:\n        print(\"Kein Vorzeichenwechsel\")\n\n    else:\n        x_old = x1\n        x_old_old = x2\n        while abs(x_old - x_old_old) > eps_stop:\n            if f.lam(x_old) != f.lam(x_old_old):\n                # Schnittstelle von Gerade durch (x_old, f(x_old) und  (x_old_old, f(x_old_old)) mit x-Achse\n                x_new = x_old - (x_old - x_old_old) / (f.lam(x_old) - f.lam(x_old_old)) * f.lam(x_old)\n\n                x_old_old = x_old\n                x_old = x_new\n            else:\n                return x_old\n        return x_new\n\n\ndef sign(x):\n    return 1 if x > 0 else 0 if x == 0 else -1\n\n\ndef nullstellen(f, a, b):\n    number_of_test_values = 1000\n\n    Values = []\n    x = a\n    schrittweite = (b - a) / number_of_test_values\n\n    # Values bestimmen auf allen Test-Punkten\n    while True:\n        Values.append([x, sign(f.lam(x))])\n        x += schrittweite\n\n        if x > b:\n            break\n\n    Nulls = []\n    Vorzeichen_wechsel = []\n\n    # Vorzeichen wechselnde Werte bestimmen\n    for i in range(len(Values) - 1):\n\n        if Values[i][1] == 0:\n            Nulls.append(Values[i][0])\n\n        elif Values[i][1] * Values[i + 1][1] < 0:\n            Vorzeichen_wechsel.append([Values[i][0], Values[i + 1][0]])\n\n    # Sekantenverfahren für alle Vorzeichenwechsel verwenden\n    for elements in Vorzeichen_wechsel:\n        Nulls.append(sekanten_verfahren(f, elements[0], elements[1]))\n\n    # Überprüfen, ob kein Fehler enstanden ist\n    for element in Nulls:\n        if f.lam(element) > 10 ** -10:\n            Nulls.remove(element)\n\n    return Nulls\n\n\ndef maximum(f, a, b):\n    n = 3000\n    x = a\n    max_fx = f.lam(x)\n    while x < b:\n        x += (b - a) / n\n        if f.lam(x) > max_fx:\n            max_fx = f.lam(x)\n        # max_x = x\n    return max_fx\n\n\ndef minimum(f, a, b):\n    n = 3000\n    x = a\n    min_fx = f.lam(x)\n    while x < b:\n        x += (b - a) / n\n        if f.lam(x) < min_fx:\n            min_fx = f.lam(x)\n        # min_x = x\n    return min_fx\n\n\n\"\"\"\ndef maximum(f,a,b):\n\t\n\t#MAN MÜSSTE lokal um UNSTETIGKEITSSTELLEN ANALYSISEREN!\n\textremstellen = [a,b]\n\textremstellen += nullstellen(f.diff(),a,b)\n\t\n\tmax_x=a\n\tmax_fx=f.lam(a)\n\tfor x in extremstellen:\n\t\tif f.lam(x) > max_fx:\n\t\t\tmax_fx = f.lam(x)\n\t\t\tmax_x = x\n\n\treturn max_fx\n\ndef minimum(f,a,b):\n\t#MAN MÜSSTE lokal um UNSTETIGKEITSSTELLEN ANALYSISEREN!\n\textremstellen = [a,b]\n\textremstellen += nullstellen(f.diff(),a,b)\n\t\n\tmin_x=a\n\tmin_fx=f.lam(a)\n\tfor x in extremstellen:\n\t\tif f.lam(x) < min_fx:\n\t\t\tmin_fx = f.lam(x)\n\t\t\tmin_x = x\n\t\n\treturn min_fx\n\"\"\"\n\n\ndef riemann(f, a, b):\n    n = 5000\n    Int = 0\n    x = a\n    schrittweite = (b - a) / n\n\n    for i in range(n):\n        Int += f.lam(a + i * schrittweite)\n\n    Int *= schrittweite\n\n    return Int\n\n\ndef trapez(f, a, b):\n    n = 5000\n    Int = 0\n    x = a\n    schrittweite = (b - a) / n\n\n    Int += 1 / 2 * f.lam(a)\n    Int += sum(f.lam(a + i * schrittweite) for i in range(n))\n    Int += 1 / 2 * f.lam(b)\n\n    Int *= schrittweite\n\n    return Int\n\n\ndef simpson(f, a, b):\n    n = 5000\n    Int = 0\n    schrittweite = (b - a) / n\n\n    Int += 1 / 2 * f.lam(a)\n    Int += sum((1 + i % 2) * f.lam(a + i * schrittweite) for i in range(1, n))\n    Int += 1 / 2 * f.lam(b)\n\n    Int *= 2 / 3 * schrittweite\n    return Int\n\n\ndef trapez_fehler(f, a, b):\n    h = (b - a) / 5000\n    return abs(1 / 12 * (b - a) * h ** 2 * maximum(f.diff().diff(), a, b))\n\n\ndef simpson_fehler(f, a, b):\n    h = (b - a) / 5000\n    g = f.diff().diff().diff().diff()\n    print(g.str)\n    return abs(1 / 180 * (b - a) * h ** 4 * maximum(g, a, b))\n\n\ndef euler_collatz(f_str,t_0,y_0,end,steps=1000):\n\t#Löse y' = f(t,y) mit y(t_0) = y_0 auf dem Intervall (t_0 ; end) mit insgesamt 1000 Iterationsschritte/Stützstellen\n    f = lambda t,y: eval(f_str.replace(\"y\",\"(\"+str(y)+\")\").replace(\"t\",\"(\"+str(t)+\")\").replace(\"^\",\"**\"))\n\n    \n    y = [0] * steps\n    y[0] = y_0\n    dt = (end - t_0)/steps \n    t = t_0\n    for i in range(1,steps):\n        y[i] = y[i-1] + dt * f(t + dt/2, y[i-1] + dt/2 * f(t,y[i-1]))\n        t += dt\n    return y  # Die Menge der Funktionswerte (die dazugehörigen x-Werte sind [ x_0 + i * dt for i in range(0,steps)])\n\n\n\n\n\nif __name__ == \"__main__\":\n    print(\"Beispiele:\\n\")\n\n    y = euler_collatz(\"y\",0,1,3) # Löse y' = y mit y(0) = 1   --> y(t) = e^t einzige Lösung\n    print(y)\n    print(\"Zum Vergleich mit dem letzten Term: \", e**3)\n    \n    print(\"\")\n    \n    y = euler_collatz(\"y^2\",0,1,0.9) #Löse y'(t) = y^2 mit y(0) = 1 auf Intervall (0,0.9) --> exakte Lösung y(t) = 1/(1-t)\n    print(y)\n    print(\"Zum Vergleich mit dem letzten Term: \", 1/(1-0.9))\n    \n    print(\"\")\n    \n    y = euler_collatz(\"y*t\",0,1,2) #Löse y'(t) = y*t mit y(0) = 1 auf Intervall (0,2) --> exakte Lösung y(t) = e^{1/2*t^2}\n    print(y)\n    print(\"Zum Vergleich mit dem letzten Term: \", e**(1/2 * 2**2))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main/analysis.py b/main/analysis.py
--- a/main/analysis.py	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
+++ b/main/analysis.py	(date 1639579761382)
@@ -1,5 +1,5 @@
 from FunctionClass import Function
-
+from functions import *
 
 def sekanten_verfahren(f, x1, x2):
     eps_stop = 10 ** -15
@@ -211,7 +211,7 @@
     
     print("")
     
-    y = euler_collatz("y^2",0,1,0.9) #Löse y'(t) = y^2 mit y(0) = 1 auf Intervall (0,0.9) --> exakte Lösung y(t) = 1/(1-t)
+    y = euler_collatz("y^2",0,1,0.99) #Löse y'(t) = y^2 mit y(0) = 1 auf Intervall (0,0.9) --> exakte Lösung y(t) = 1/(1-t)
     print(y)
     print("Zum Vergleich mit dem letzten Term: ", 1/(1-0.9))
     
@@ -220,3 +220,5 @@
     y = euler_collatz("y*t",0,1,2) #Löse y'(t) = y*t mit y(0) = 1 auf Intervall (0,2) --> exakte Lösung y(t) = e^{1/2*t^2}
     print(y)
     print("Zum Vergleich mit dem letzten Term: ", e**(1/2 * 2**2))
+    
+    
\ No newline at end of file
Index: main/matrix.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from random import randint\nfrom functions import sqrt\nfrom time import time\n\n\ndef rint(x):\n    if round(x,4) == round(x):\n        return round(x)\n    else:\n        return round(x,2)\n\nclass Matrix():\n    def __init__(self,args):\n        \n        #Definiere eine Class für Zeilen, um addieren zu können\n        #(Es gibt keine Vector class, da sie eig. Matrizen sind)\n        class matrix_row():\n            #Spalten_vektor\n            def __init__(self,args):\n                self.vector = args\n                self.rows = len(args)\n                self.cols = 1\n        \n            def __str__(self):\n                text = \"\"\n                for element in self.vector:\n                    if element == 0:\n                        text += \".\"+\" \"*5\n                    else:\n                        text += str(round(element,2))+\" \"*(6-len(str(round(element,2))))\n                    text += \"\\n\"\n                return text\n        \n            def __getitem__(self, i):\n                return self.vector[i]\n        \n            def __setitem__(self, idx, val):\n                self.vector[idx] = val\n\n            def __len__(self):\n                return self.rows\n        \n            def __add__(self, val):\n                if len(self) == len(val):\n                    return self.__class__([self.vector[i] + val.vector[i] for i in range(len(self))])\n                else:\n                    raise ValueError\n        \n            def __rmul__(self, val):\n                return self.__class__([val * self.vector[i] for i in range(len(self))])\n            \n            def __mul__(self, val):\n                return self.__class__([val * self.vector[i] for i in range(len(self))])\n        \n            def __neg__(self):\n                return -1*self\n        \n            def __sub__(self, val):\n                return self + - val\n        \n            def __eq__(self, val):\n                return self.vector == val.vector\n\n        self.row = [matrix_row(vec) for vec in args]\n\n        self.rows = len(args)\n        self.cols = len(args[0])\n\n    def __getitem__(self, i):\n        try:\n            return self.row[i]\n        except:\n            print(\"Der gegebene Index ist falsch\")\n\n    def __setitem__(self, idx, val):\n        try:\n            if len(val) == self.cols:\n                self.row[idx] = val\n            else:\n                raise ValueError\n        except:\n            print(\"Der gegebene Index ist falsch, oder die gegebene Zeile nicht korrekt formatiert\")\n    \n\n        \n    def __str__(self):\n        text = \"\"\n        for row in self.row:\n            for element in row:\n                if abs(element) <= 0.00001:\n                    text += \".\"+\" \"*5\n                else:\n                    text += str(rint(element))+\" \"+\" \"*(5-len(str(rint(element))))\n            text += \"\\n\"\n        return text\n\n\n    def __add__(self,val):\n        try:\n            if self.rows == val.rows and self.cols == val.cols:\n                return self.__class__([[self[i][j] + val[i][j] for j in range(self.cols)] for i in range(self.rows)])\n            else:\n                raise ValueError\n        except:\n            print(\"Die gegebenen Matrizen können nicht addiert werden\")\n            \n    def __rmul__(self, val):\n        return self.__class__([[val * self[i][j] for j in range(self.cols)] for i in range(self.rows)])\n    \n    def __neg__(self):\n        return -1*self\n\n    def __sub__(self, val):\n        return self + -val\n\n    def __eq__(self, val):\n        return self.row == val.row\n\n    def __mul__(self, val):\n        try:\n            if type(val) == float or type(val) == int:\n                return self.__class__([[val * self[i][j] for j in range(self.cols)] for i in range(self.rows)])\n            \n            elif self.cols == val.rows:\n                return self.__class__([[sum(self[i][k]*val[k][j] for k in range(self.cols)) for j in range(val.cols)] for i in range(self.rows)])\n            \n            else:\n                raise ValueError\n        except:\n            print(\"Die Matrizen sind nicht kompatibel\")\n\n\n\n    @classmethod\n    def Random(cls, m, n, low=0, high=10):\n        row = []\n        for _ in range(m):\n            row.append([randint(low, high) for _ in range(n)])\n        return Matrix(row)\n\n    @classmethod\n    def RandomSym(cls, m, low=0, high=10):\n        row = []\n        for _ in range(m):\n            row.append([randint(low, high) for _ in range(m)])\n\n        for i in range(m):\n            for j in range(m):\n                row[i][j] = row[j][i]\n\n        return Matrix(row)\n\n    @classmethod\n    def Zero(cls, m, n):\n        rows = [[0]*n for _ in range(m)]\n        return Matrix(rows)\n\n    @classmethod\n    def Id(cls, m):\n        row = [[0]*m for _ in range(m)]\n        index = 0\n\n        for r in row:\n            r[index] = 1\n            index += 1\n\n        return Matrix(row)\n\n\n    #Mathematische Funktionen\n\n\n    def T(self):\n        return self.__class__([[self[j][i] for j in range(self.rows)] for i in range(self.cols)])\n\n    def s(self,i,j,lam):\n        #zur i-ten Zeile das lam-Fache der j-ten Zeile hinzufügen\n        self[i] += lam * self[j]\n\n    def m(self,i,lam):\n        self[i] = lam * self[i]\n\n    def v(self,i,j):\n        self[i], self[j] = self[j], self[i]\n\n    def sq(self):\n        return self*self\n\n    def __pow__(self, n):\n        return self if n == 1 else  (self ** (n/2)).sq() if n % 2 == 0 else self * (self ** (n-1))\n    \n    def normZ(self):\n        return max(sum(line) for line in self.row)  #Zeilensummen-Norm\n\n    def normS(self):\n        return max(sum(line) for line in self.T().row)  #Spaltensummen-Norm\n    \n    \n    def lu(self):\n        if self.rows == self.cols:\n            try:\n                n = self.rows \n                \n                L = Matrix.Id(n)\n                U = Matrix.Zero(n, n)\n                \n                for i in range(0, n):\n                    for k in range(i, n):\n                        U[i][k] = self[i][k] - sum(L[i][j] * U[j][k] for j in range(0, i))\n                    \n                    for k in range(i + 1, n):\n                        L[k][i] = (self[k][i] - sum(L[k][j] * U[j][i] for j in range(0, i))) / U[i][i]\n                return [L, U]\n            except:\n                print(\"Die Untermatrizen der Matrix sind nicht alle regulär, also ist die LU-Zerlegung unmöglich!\")\n        else:\n            print(\"Die Matrix muss quadratisch sein!\")\n    \n    def lu_solve(self, b):\n        def upper_triangle_solve(A, b):\n            try:\n                x = Matrix.Zero(b.rows, 1)\n                for i in range(b.rows - 1, -1, -1):\n                    summe = sum(A[i][j] * x[j][0] for j in range(i + 1, b.rows))\n                    x[i][0] = ((b[i][0] - summe) / A[i][i])\n                return x\n            \n            except:\n                print(\"A ist nicht regulär!\")\n                \n        def lower_triangle_solve(A, b):\n            try:\n                x = Matrix.Zero(b.rows, 1)\n                \n                for i in range(0, b.rows):\n                    summe = sum(A[i][j] * x[j][0] for j in range(0, i))\n                    x[i][0] = ((b[i][0] - summe) / A[i][i])\n                return x\n            \n            except:\n                print(\"A ist nicht regulär!\")\n        \n        \n        try:\n            [L,U] = self.lu()\n\n            y = lower_triangle_solve(L, b)\n            x = upper_triangle_solve(U, y)\n            \n            return x\n        except:\n            print(\"LU Zerlegung nicht möglich\")\n    \n            \n    def cholesky(self):\n\n        if self.rows == self.cols:\n            if self == self.T():\n                try:\n                    n = self.rows\n                    L = Matrix.Zero(n, n)\n                    for k in range(0, n):\n                        L[k][k] = sqrt(self[k][k] - sum(L[k][j] * L[k][j] for j in range(0, k)))  # 0der range(0,k-1)?\n                        for i in range(k, n):\n                            L[i][k] = (self[i][k] - sum(L[i][j] * L[k][j] for j in range(0, k))) / L[k][k]\n                    return L\n                    \n                    \n                except:\n                    print(\"Die Matrix ist nicht positiv definit, also funktioniert die Cholesky-Zerlegung nicht.\")\n                \n            else:\n                print(\"Die Matrix ist nicht symmetrisch. Cholesky-Zerlegung funktioniert nur für positiv definite SYMMETRISCHE Matrizen\")\n        else:\n            print(\"Die Matrix muss quadratisch sein! Cholesky nicht anwendbar.\")\n    \n    def cholesky_solve(self,b):\n        def upper_triangle_solve(A, b):\n            try:\n                x = Matrix.Zero(b.rows, 1)\n                for i in range(b.rows - 1, -1, -1):\n                    summe = sum(A[i][j] * x[j][0] for j in range(i + 1, b.rows))\n                    x[i][0] = ((b[i][0] - summe) / A[i][i])\n                return x\n            \n            except:\n                print(\"A ist nicht regulär!\")\n                \n        def lower_triangle_solve(A, b):\n            try:\n                x = Matrix.Zero(b.rows, 1)\n                \n                for i in range(0, b.rows):\n                    summe = sum(A[i][j] * x[j][0] for j in range(0, i))\n                    x[i][0] = ((b[i][0] - summe) / A[i][i])\n                return x\n            \n            except:\n                print(\"A ist nicht regulär!\")\n        \n        \n        try:\n            L = self.cholesky()\n\n            y = lower_triangle_solve(L, b)\n            x = upper_triangle_solve(L.T(), y)\n            \n            return x\n        except:\n            print(\"LU Zerlegung nicht möglich\")\n        \n    \n    def sub_matrix(self,ymin,ymax,xmin,xmax):\n        coeffs =[]\n        for y in range(ymin,ymax):            \n            coeffs += [self[y][xmin:xmax]]\n\n        return Matrix(coeffs)\n    \n    \n    def gauss_explained(self, b_in):\n        def Mprint(self,b):\n            text = \"\"\n            for i in range(self.rows):\n                for element in self[i]:\n                    if element == 0:\n                        text += \".\"+\" \"*4\n                    else:\n                        if element > 0:\n                            text += str(rint(element))+\" \"+\" \"*(4-len(str(rint(element))))\n                        else:\n                            text += str(rint(element))+\" \"+\" \"*(4-len(str(rint(element))))\n                text += \"   |    \"\n                \n                element = b[i][0]\n                \n                if element == 0:\n                    text += \".\"+\" \"*4\n                else:\n                    if element > 0:\n                        text += str(rint(element))+\" \"+\" \"*(4-len(str(rint(element))))\n                    else:\n                        text += str(rint(element))+\" \"+\" \"*(4-len(str(rint(element))))\n                \n                text += \"\\n\"\n            print(text)\n\n        n = self.rows\n        V = 0\n        M = self.T().T()  #Damit der eigentliche Wert von self nicht verändert wird\n        b = b_in.T().T()  #  \"\n\n        L = Matrix.Zero(n, n)\n        transpositions = []\n        Operationen = []\n\n        for k in range(0, n - 1):\n            print(\"°~\" * 50)\n            print(\"NEUE ITERATION\")\n            Mprint(M, b)\n            # maximal pivot\n            index = k\n            for l in range(k, n):\n                if abs(M[l][k]) > abs(M[index][k]):\n                    index = l\n\n            # transpose\n            if index != k:\n                print(\"Maximal Pivot-Wert:\", M[index][k])\n                V += 1\n                M[k], M[index] = M[index], M[k]\n                b[k], b[index] = b[index], b[k]\n                transpositions.append([k, index])\n                Operationen.append([\"V\", k, index])\n                print(\"Vertauschung:\")\n                Mprint(M, b)\n\n            print(\"---\" * 20)\n            print(\"Rechnung:\")\n            Mprint(M, b)\n            # Operate\n            if M[k][k] != 0:\n                for i in range(k + 1, n):\n                    L[i][k] = M[i][k] / M[k][k]\n\n                    b.s(i, k, -L[i][k])\n                    M.s(i, k, -L[i][k])\n                    Operationen.append([\"S\", i, k, - L[i][k]])\n                    print(\"S(\", i, \",\", k, \",\", - L[i][k], \")\")\n\n                    Mprint(M, b)\n\n        # Triangle Zu identität\n        print(\"=-=|\" * 60)\n        print(\"Nächste Phase:\")\n        print(\"Normierung:\")\n\n        for i in range(n - 1, -1, -1):\n            Operationen.append([\"M\", i, 1 / M[i][i]])\n            b.m(i, 1 / M[i][i])\n            M.m(i, 1 / M[i][i])\n        \n        Mprint(M, b)\n        print(\"Kürzung:\")\n        for i in range(n - 1, -1, -1):\n            Mprint(M, b)\n            for k in range(i):\n                Operationen.append([\"S\", k, i, - M[k][i]])\n                b.s(k, i, -M[k][i])\n                M.s(k, i, -M[k][i])\n\n        pi = transpositions[::-1]\n        return [M, b, V, pi, Operationen]\n    \n    def gauss(self,b_in):\n        n = self.rows\n        V = 0\n        M = self.T().T()  #Damit der eigentliche Wert von self nicht verändert wird\n        b = b_in.T().T()  #  \"\n\n        L = Matrix.Zero(n, n)\n        transpositions = []\n        Operationen = []\n\n        for k in range(0, n - 1):\n\n            # maximal pivot\n            index = k\n            for l in range(k, n):\n                if abs(M[l][k]) > abs(M[index][k]):\n                    index = l\n\n            # transpose\n            if index != k:\n                V += 1\n                M[k], M[index] = M[index], M[k]\n                b[k], b[index] = b[index], b[k]\n                transpositions.append([k, index])\n                Operationen.append([\"V\", k, index])\n\n            # Operate\n            if M[k][k] != 0:\n                for i in range(k + 1, n):\n                    L[i][k] = M[i][k] / M[k][k]\n\n                    b.s(i, k, -L[i][k])\n                    M.s(i, k, -L[i][k])\n                    Operationen.append([\"S\", i, k, - L[i][k]])\n\n        # Triangle Zu identität\n        for i in range(n - 1, -1, -1):\n            Operationen.append([\"M\", i, 1 / M[i][i]])\n            b.m(i, 1 / M[i][i])\n            M.m(i, 1 / M[i][i])\n        \n\n        for i in range(n - 1, -1, -1):\n            for k in range(i):\n                Operationen.append([\"S\", k, i, - M[k][i]])\n                b.s(k, i, -M[k][i])\n                M.s(k, i, -M[k][i])\n\n        pi = transpositions[::-1]\n        return [M, b, V, pi, Operationen]\n    \n    def gauss_solve(self, b):\n        def permutate(b, T):\n            for i in range(len(T)):\n                b[T[i][0]], b[T[i][1]] = b[T[i][1]], b[T[i][0]]\n        \n        List = self.gauss(b)\n        x = List[1]\n\n        return x\n\n    def inverse(self):\n        try:\n            def apply_operations(operations, n):\n                I = Matrix.Id(n)\n                for op in operations:\n                    if op[0] == 'V':\n                        I[op[1]], I[op[2]] = I[op[2]], I[op[1]]\n                    elif op[0] == 'M':\n                        I.m(op[1], op[2])\n                    else:\n                        I.s(op[1], op[2], op[3])\n                return I\n    \n            op = self.gauss(Matrix.Zero(self.rows,1))[4]\n            return apply_operations(op, self.rows)\n        except:\n            print(\"Matrix nicht invertierbar.\")\n    \n    def det(self):\n        try:\n            op = self.gauss(Matrix.Zero(self.rows,1))[4]\n            determinant = 1\n            for operation in op:\n                if operation[0] == \"M\":\n                    determinant /= operation[2]\n                if operation[0] == \"V\":\n                    determinant *= -1\n            return determinant\n        except:\n            return 0\n\n    #Matrix egal  A=QR\n    def QR(self):\n        def sign(x):\n            return 1 if x >= 0 else -1\n        def norm(a):\n            return sqrt(sum(a[i][0]**2 for i in range(a.rows)))\n        \n        R = self.T().T()\n        n, m = R.rows, R.cols\n        Q = Matrix.Id(n)\n    \n        for i in range(0, m):\n            a = Matrix([[R[k][i]] for k in range(i, n)]) #Spaltenvektor\n            if norm(a) != 0:\n                sigma = -sign(a[0][0])\n                a[0][0] -= sigma * norm(a)            \n                v1 = 1 /norm(a) * a\n                v = Matrix.Zero(n, 1)            \n                for k in range(i,n):    v[k] = v1[k-i]\n    \n    \n                R -= (2 * v) * (v.T() * R)\n                Q -= v * (2 * v.T()) * Q\n            \n                        \n        return [Q.T(), R]\n\n    #Überbestimmte Aufgabe lösen\n    \n    def ausgleichs_problem(self,b):\n        def upper_triangle_solve(A, b):\n            try:\n                x = Matrix.Zero(b.rows, 1)\n                for i in range(b.rows - 1, -1, -1):\n                    summe = sum(A[i][j] * x[j][0] for j in range(i + 1, b.rows))\n                    x[i][0] = ((b[i][0] - summe) / A[i][i])\n                return x\n            \n            except:\n                print(\"A ist nicht regulär!\")\n        \n        [Q,R] = self.QR()\n        v = Q.T() * b\n        c = v.sub_matrix(0,0,0,self.cols-1)\n        R_hat = R.sub_matrix(0,R.rows-1,0,R.rows-1)\n        return upper_triangle_solve(R_hat, c)\n    \n    \n    #Reel Diagonalisierbar:\n    \n    def power_method(self):\n        def norm(a):\n            return sqrt(sum(a[i][0]**2 for i in range(a.rows)))\n        \n        x = Matrix([[1] for _ in range(self.rows)])\n        mu = 1\n        for i in range(100):\n            print(mu)\n            mu_old = mu\n            x = A * x\n            mu = norm(x)\n            x = 1 / mu * x\n            if abs(mu_old - mu) < 0.0000000001:\n                break;\n        if abs(mu_old - mu) < 0.0000000001:\n            return mu\n        else:\n            print(\"Potenz-Methode geht nicht, da A nicht reell diagonalisierbar ist.\")\n\n    def hesseberg(self):\n        def sign(x):\n            return 1 if x >= 0 else -1\n        def norm(a):\n            return sqrt(sum(a[i][0]**2 for i in range(a.rows)))\n        \n        R = self.T().T()\n        n = R.rows\n    \n        for i in range(0, n - 1):\n            a = Matrix([[R[k][i]] for k in range(i+1, n)]) #Spaltenvektor\n            sigma = -sign(a[0][0])\n            a[0][0] -= sigma * norm(a)            \n            v1 = 1 /norm(a) * a\n            v = Matrix.Zero(n, 1)    \n            for k in range(i+1,n):    v[k] = v1[k-i-1]\n\n            R -= (2 * v) * (v.T() * R)\n            R -= 2 * (R * v) * v.T()\n\n        return R\n\n    \n    def jacobi(self): #32 n^2\n        if self.T() == self:\n            \n            \n            def givens_quick_calculation(A, i, j):\n                def sign(x):\n                    return 1 if x >= 0 else -1\n                def sqrt(x):\n                    if x < 0 and round(x, 10) == 0.0:\n                        x = 0\n                    if x > 0:\n                        a = x\n                        for i in range(25):\n                            a = 1 / 2 * (a + x / a)\n                        return a\n                    elif x == 0:\n                        return 0\n                    else:\n                        print(\"NEGATIV!\")\n                D = (A[i][i] - A[j][j]) / sqrt((A[i][i] - A[j][j]) ** 2 + 4 * A[i][j] ** 2)\n                c = sqrt((1 + D) / 2)\n                s = -sign(A[i][j]) * sqrt((1 - D) / 2)\n            \n                ci = []\n                cj = []\n                for k in range(A.rows):\n                    ci.append(A[i][k] * c - A[j][k] * s)\n                    cj.append(A[i][k] * s + A[j][k] * c)\n                A[i][:] = ci\n                A[j][:] = cj\n            \n                ri = []\n                rj = []\n                for k in range(A.rows):\n                    ri.append(A[k][i] * c - A[k][j] * s)\n                    rj.append(A[k][i] * s + A[k][j] * c)\n                for k in range(A.rows):\n                    A[k][i] = ri[k]\n                    A[k][j] = rj[k]\n                return A\n            def N(A):\n                return sum([sum([float(i != j) * A[i][j] ** 2 for i in range(A.rows)]) for j in range(A.rows)])\n            \n            A = self.T().T()\n            n = self.rows\n            i, j = 1, 0\n            # zyklisch schneller als maximierend\n            for r in range(10000000):\n                if i < n - 1:\n                    i += 1\n                elif i == n - 1 and j < n - 2:\n                    j += 1\n                    i = j + 1\n                else:\n                    i, j = 1, 0\n        \n                A = givens_quick_calculation(A, i, j)  # imax,jmax\n        \n                if r % 100 == 0:\n                    delta = N(A)\n                    print(delta)\n                    if delta < 0.0000001:\n                        return [A[i][i] for i in range(n)]\n        else:\n            print(\"Matrix ist nicht symmetrisch. Jacobi-Vefahren nicht anwendbar.\")\n\n    def RQ_hesseberg(self):\n        # A [=QR] in hessberg form |-> RQ\n        def givensrotation(a,b):\n            if b == 0:\n                c = 1\n                s = 0\n            else:\n                if abs(b) > abs(a):\n                    r = a / b\n                    s = 1 / sqrt(1 + r**2)\n                    c = -s*r\n\n                else:\n                    r = b / a\n                    c = 1 / sqrt(1 + r**2)\n                    s = -c*r\n            return [c,s]\n\n        R = self.T().T()\n        n = R.rows\n        \n        C  = []\n        S = []\n\n        for k in range(n-1):\n            [c,s] = givensrotation( R[k][k], R[k+1][k] )\n\n            C += [c]\n            S += [s]\n\n            A = R.sub_matrix(k,k+2,k,n)\n            \n            j = 0\n            for l in range(k,n):\n                R[k][l]   = c * A[0][j] - s * A[1][j]\n                R[k+1][l] = s * A[0][j] + c * A[1][j]\n                j += 1\n\n        for k in range(n-1):\n            c, s = C[k], S[k]\n            \n            A = R.sub_matrix(0,k+2,k,k+2)\n\n            j = 0\n            for l in range(k+2):\n                R[l][k]   =  c * A[j][0] - s * A[j][1]\n                R[l][k+1] =  s * A[j][0] + c * A[j][1]\n                j += 1\n        return R\n    \n    def eigenvalues(self,iter = -1):\n        if iter == -1:\n            iter = 40 * self.rows\n        def QR_verfahren(self):\n\n            M = self.hesseberg()\n            n = M.rows\n        \n            for i in range(iter):\n                if i % 20 == 0:\n                    #print(M)\n                    print(100 * i / iter, \"%\")\n                kappa = M[n-1][n-1]\n                M = (M - kappa*Matrix.Id(n)).RQ_hesseberg()  +  kappa*Matrix.Id(n)\n\n            return M\n        \n        def block(B):\n            block_matrizen = []\n            n = B.rows\n        \n            if round(B[1][0], 2) == 0.0:\n                block_matrizen.append(B[0][0])\n            else:\n                block_matrizen.append([[B[0][0], B[0][1]], [B[1][0], B[1][1]]])\n        \n            for k in range(1, n - 1):\n                if round(B[k + 1][k], 2) != 0.0:\n                    block_matrizen.append([[B[k][k], B[k][k + 1]], [B[k + 1][k], B[k + 1][k + 1]]])\n                elif round(B[k][k - 1], 2) == 0.0:\n                    block_matrizen.append(B[k][k])\n        \n            if round(B[n - 1][n - 2], 2) == 0.0:\n                block_matrizen.append(B[n - 1][n - 1])\n        \n            return block_matrizen\n        \n        if self == self.T():\n            return [[B,0] for B in self.jacobi()]\n\n        B = QR_verfahren(self)\n    \n        blocks = block(B)\n        eigenwerte = []\n        for M in blocks:\n            if type(M) == int or type(M) == float:\n                eigenwerte.append([M, 0.0])\n            else:\n                C_1 = -M[0][0] - M[1][1]\n                C_2 = -M[1][0] * M[0][1] + M[0][0] * M[1][1]\n    \n                eigenwerte.append([-C_1 / 2, 1 / 2 * sqrt(abs(C_1 * C_1 - 4 * C_2))])\n                eigenwerte.append([-C_1 / 2, -1 / 2 * sqrt(abs(C_1 * C_1 - 4 * C_2))])\n        return eigenwerte\n\nA = Matrix.Random(20, 20, -10, 10)\nprint(A)\n\nt = time()\nprint(A.eigenvalues())\nprint( time() - t )\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main/matrix.py b/main/matrix.py
--- a/main/matrix.py	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
+++ b/main/matrix.py	(date 1639578371386)
@@ -129,8 +129,6 @@
         except:
             print("Die Matrizen sind nicht kompatibel")
 
-
-
     @classmethod
     def Random(cls, m, n, low=0, high=10):
         row = []
@@ -657,6 +655,7 @@
                 if r % 100 == 0:
                     delta = N(A)
                     print(delta)
+                    print(A)
                     if delta < 0.0000001:
                         return [A[i][i] for i in range(n)]
         else:
@@ -718,11 +717,12 @@
         def QR_verfahren(self):
 
             M = self.hesseberg()
+            print(M)
             n = M.rows
         
             for i in range(iter):
-                if i % 20 == 0:
-                    #print(M)
+                if i % 10 == 0:
+                    print(M)
                     print(100 * i / iter, "%")
                 kappa = M[n-1][n-1]
                 M = (M - kappa*Matrix.Id(n)).RQ_hesseberg()  +  kappa*Matrix.Id(n)
@@ -767,10 +767,11 @@
                 eigenwerte.append([-C_1 / 2, -1 / 2 * sqrt(abs(C_1 * C_1 - 4 * C_2))])
         return eigenwerte
 
-A = Matrix.Random(20, 20, -10, 10)
+A = Matrix.RandomSym(30, -10, 10)
 print(A)
 
 t = time()
 print(A.eigenvalues())
 print( time() - t )
 
+print(A.power_method())
\ No newline at end of file
Index: main/WolframBeta.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from tkinter import Tk, Frame, Label, Entry, Button, PhotoImage, OptionMenu, StringVar, Radiobutton\n\nfrom matplotlib.figure import Figure\nimport matplotlib.pyplot as plt\nfrom matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n\nfrom FunctionClass import Function, write_latex, NUMBERS, ALPHABET, flint\nfrom analysis import nullstellen, minimum, maximum, riemann, trapez, simpson, trapez_fehler, simpson_fehler\nfrom functions import *\n\nlblue = \"#1e3799\"\ndblue = \"#001B81\"\nlgray = \"#d9d9d9\"\ndgray = \"#404040\"\nselection = 0  # Auswahl links\nlang = 0  # Deutsch: 0, Francais: 1, English: 2\ncolor_mode = 0  # 0: lightmode, 1: darkmode\nfigures = []  # beide (Figure, Canvas)\nmemory_dict = {}  # Speicher für userinputs\nhistory = ()\n\"\"\"\nAndere Funktionen:\n- nullstellen (f(x) = 0)\n- min(), max()\n- Fläche (integral mit Riemann, Trapez oder simpson (Auswahl))\n- dafür optional fehler bestimmen\n\n\n\"\"\"\n\n\ndef toggle_color_mode(containers):\n    global color_mode\n    color_mode = 1 if color_mode == 0 else 0\n    toggle_color_button.config(image=[darkmode_image, lightmode_image][color_mode],\n                               text=[\"Darkmode\", \"Lightmode\"][color_mode]\n                               )\n    \n    for container in containers:\n        container[\"bg\"] = [lgray, dgray][color_mode]\n        if type(container) == Entry:\n            container[\"fg\"] = [\"black\", \"white\"][color_mode]\n        elif type(container) == Button:\n            container[\"fg\"] = [\"black\", \"white\"][color_mode]\n            container[\"activebackground\"] = [\"#ececec\", \"#4c4c4c\"][color_mode]\n            container[\"activeforeground\"] = [\"black\", \"#f0f0f0\"][color_mode]\n            container[\"fg\"] = [\"black\", \"#f0f0f0\"][color_mode]\n    \n    (input_fig, input_canvas), (out_fig, out_canvas) = figures\n    input_fig.set_facecolor([\"white\", \"#505050\"][color_mode])\n    out_fig.set_facecolor([\"white\", \"#505050\"][color_mode])\n    input_canvas.draw()\n    out_canvas.draw()\n\n\ndef toggle_lang(language):\n    global lang\n    lang = lang_selection.get()\n\n    \ndef integrate(function=None, variable=None, methodstr=None, lower=None, upper=None):\n    method = methodstr.get()\n    global history\n    if function:\n        history = function, variable, lower, upper\n    else:\n        function, variable, lower, upper = history\n\n    if not (lower or upper):\n        return \"\"\n    f = Function(function, variable)\n    if method == \"riemann\":\n        return riemann(f, lower, upper)\n    elif method == \"trapez\":\n        return trapez(f, lower, upper)\n    elif method == \"simpson\":\n        return simpson(f, lower, upper)\n\n# Int_1^3(x^2)dx\n\n\ndef interprete(f):\n    if f.startswith(\"Int\") and f[-3:-1] == \")d\" and isinstance(f[-1], str):\n        if f[3] == \"(\":\n            var = f[-1]\n            function = f[4:-3]\n            show_error([\"Nicht berechenbar!\", \"Non-calculable!\", \"Not computable!\"][lang])\n            return r\"\\int \" + write_latex(function) + \" d\" + var, \"\", \"\"\n        elif f[3] == \"_\":  # \"Int_12,3^1,23(f)dx\"\n            lower_bound, i = \"\", 4\n            while f[i] in NUMBERS + \",eπ\":\n                lower_bound += f[i]\n                i += 1\n            upper_bound = \"\"\n            i += 1\n            while f[i] in NUMBERS + \",eπ\":\n                upper_bound += f[i]\n                i += 1\n            var = f[-1]\n            function = f[i + 1:-3]\n            \n            method = StringVar(value=\"riemann\")\n            b1 = Radiobutton(einstellungs_frame, text=\"Riemann\", variable=method, value=\"riemann\").pack()\n            b2 = Radiobutton(einstellungs_frame, text=\"Trapez\", variable=method, value=\"trapez\").pack()\n            b3 = Radiobutton(einstellungs_frame, text=\"Simpson\", variable=method, value=\"simpson\").pack()\n            method.trace(\"w\", integrate)\n            \n            latex_input = rf\"\\int_{'{'}{lower_bound}{'}^{'}{upper_bound}{'}'}{write_latex(function)}d{var}\"\n            return latex_input, integrate(function, var, method, flint(lower_bound), flint(upper_bound)), \"\"\n    else:\n        return None\n\n\ndef raise_error(error):\n    # print(\"error:\", repr(error))\n    # print(\"error.args:\", error.args)\n    \n    if error.args:\n        if len(error.args) > 1:\n            # Error mit verschieden Sprachen\n            err = error.args[lang]\n        else:\n            err = error.args[0]\n    else:\n        # zb: ZeroDivisionError (hat keine args)\n        # repr(error) würde ZeroDivisionError() ausgeben, man will die klammern weghaben\n        err = repr(error)[:-2]\n    show_error(err)\n\n\ndef calculate(userinput):\n    userinput = userinput.replace(\" \", \"\").replace(\"**\", \"^\")\n    userinput = userinput.replace(\"²\", \"^2\").replace(\"³\", \"^3\")\n    userinput = userinput.replace(\"pi\", \"π\")\n    \n    for chr in userinput:\n        if chr not in \".,+-*/()_^`' π\" + NUMBERS + ALPHABET:\n            show_error(f\"Invalid input: '{chr}'\")\n            return\n    if userinput.count(\"(\") != userinput.count(\")\"):\n        show_error([\"Klammern unpaarig\", \"Il manque au moins une parenthese\", \"Unmatched parentheses\"][lang])\n        return\n    if userinput[0] in \"*/^'`\":\n        show_error(f\"{['Erstes Zeichen kann nicht sein', 'Premier charactère ne peut pas être', 'First character cannot be'][lang]}: '{userinput[0]}'\")\n        return\n    if userinput[-1] in \"+-*/^\":\n        show_error(f\"{['Letztes Zeichen kann nicht sein', 'Dernier charactère ne peut pas être', 'Last character cannot be'][lang]}: '{userinput[-1]}'\")\n        return\n        \n    output_str = userinput\n    \n    # # Derivative\n    # def derivative(userinput, var):\n    #     try:\n    #         F = Function(userinput, var)\n    #         answer = F.diff()\n    #     except Exception as error:\n    #         return error, None\n    #     return answer.str, answer.latex\n    #\n    # if userinput.startswith(\"d/d\"):\n    #     var = userinput[3]\n    #     if var == \" \":\n    #         return f\"Invalid syntax: {userinput[:4]}\"\n    #\n    #     userinput = userinput[4:].lstrip()\n    #     print(userinput, var)\n    #     return derivative(userinput, var)\n    #\n    # elif userinput.startswith(\"(\") and userinput.endswith((\")'\", \")`\")):\n    #     userinput = userinput[1:-2]\n    #     return derivative(userinput, \"x\")\n    try:\n        maybe_something = interprete(userinput)\n        \n        if not maybe_something:\n            function = Function(userinput)\n            \n            userinput_latex = function.latex_in\n            output_str = function.str_out\n            output_latex = function.latex_out\n        else:\n            return maybe_something\n    \n    except Exception as error:\n        raise_error(error)\n        return\n    \n    try:\n        # Falls man eine approximativen Wert berechnen kann\n        output_str += f\"\\n\\n≈ {eval(output_str)}\"\n    except Exception:\n        pass\n    \n    return userinput_latex, output_latex, output_str\n\n\ndef get_user_input(_=None):\n    user_input = inputentry.get()\n    if not user_input:\n        return\n    if user_input in memory_dict:\n        show_answer(*memory_dict[user_input])\n    else:\n        answers = calculate(user_input)\n        if not answers: return\n        show_answer(*answers)\n        memory_dict[user_input] = [*answers]\n\n\ndef show_error(err):\n    error_label.config(text=err)\n    print(f\"Error: {err}\")\n\n\ndef show_answer(*answers):\n    show_error(\"\")\n    userinput_latex, output_latex, output_str = answers\n    (input_fig, input_canvas), (out_fig, out_canvas) = figures\n    \n    input_fig.clear()\n    latex_input = r\"${}$\".format(userinput_latex)\n    l = len(latex_input)\n    size = int(1800 / (l + 50))\n    # print(f\"INPUT: {size = }, {len(latex_input) = }\")\n    if latex_input != \"$$\":\n        input_fig.text(10 / (l + 18), 0.5, latex_input, fontsize=size, color=[\"black\", \"white\"][color_mode])\n    input_canvas.draw()\n    \n    out_fig.clear()\n    text = r\"${}$\".format(output_latex)\n    l = len(text)\n    size = int(2000 / (l + 50))\n    # print(f\"OUTPUT: {size = }, {l = }\")\n    if text != \"$$\":\n        out_fig.text(10 / (l + 18), 0.45, text, fontsize=size, color=[\"black\", \"white\"][color_mode])\n    out_canvas.draw()\n    \n    # outlabel[\"text\"] = output_str\n\n\ndef selection_buttons(container, function, *names):\n    buttons = []\n    \n    whitebg = Label(container)\n    whitebg.place(rely=0.01, relx=0.05, relwidth=0.9, relheight=len(names) / 10 - 0.01)\n    \n    for i, name in enumerate(names):\n        button = Button(container,\n                        text=name,\n                        bg=lblue,\n                        fg=\"white\",\n                        highlightthickness=0,\n                        bd=0,\n                        activebackground=dblue,\n                        activeforeground=\"white\",\n                        command=lambda n=i + 1: eval(function)(n))\n        button.place(rely=i / 10, x=0, relwidth=1, relheight=0.099)\n        buttons.append(button)\n    \n    return buttons\n\n\ndef clear_frame():\n    for widget in selectframe.winfo_children():\n        widget.destroy()\n\n\ndef select(topic):\n    global selection\n    selection = topic if selection != topic else 0\n    \n    clear_frame()\n    for i in range(3):\n        buttons[i][\"bg\"] = lblue\n    \n    if selection == 1:\n        buttons[0][\"bg\"] = dblue\n        selection_buttons(selectframe, \"analysis\", \"Ableitung\", \"Integral\", \"Grenzwert\", \"Graph\")\n    if selection == 2:\n        buttons[1][\"bg\"] = dblue\n        selection_buttons(selectframe, \"algebra\", \"Matrizen\")\n    if selection == 3:\n        buttons[2][\"bg\"] = dblue\n        selection_buttons(selectframe, \"numbers\", \"Zahlentheorie\")\n\n\ndef analysis(n):\n    print(\"ana: \", n)\n    \n    if n == 1:\n        inputentry.insert(0, \"d/dx(\")\n        inputentry.insert(\"end\", \")\")\n    if n == 2:\n        inputentry.insert(0, \"Int_^(\")\n        inputentry.insert(\"end\", \")dx\")\n    if n == 3:\n        inputentry.insert(0, \"lim \")\n\n\ndef algebra(n):\n    print(\"algebra: \", n)\n\n\ndef numbers(n):\n    print(\"numbers: \", n)\n\n\ndef create_screen():\n    root = Tk()\n    # matplotlib.use('TkAgg')\n    plt.rcParams[\"mathtext.fontset\"] = \"cm\"\n    \n    sw = root.winfo_screenwidth()  # 1680\n    sh = root.winfo_screenheight()  # 1050\n    sh, sw = 500, 700\n    \n    root.geometry(f\"{sw}x{sh}\")\n    root.title(\"Wolframbeta\")\n    \n    # Topframe\n    topframe = Frame(root)\n    topframe.place(y=0, relx=0.1, relheight=0.1, relwidth=0.9)\n    \n    topframe.columnconfigure(0, weight=5)\n    topframe.rowconfigure(0, weight=1)\n    \n    logopic = PhotoImage(file=\"../pictures/logo.png\").subsample(2, 2)\n    logo = Label(topframe, image=logopic)\n    logo.grid(row=0, column=0, sticky=\"news\")\n    \n    global toggle_color_button\n    global darkmode_image\n    global lightmode_image\n    darkmode_image = PhotoImage(file=\"../pictures/darkmode.png\")\n    lightmode_image = PhotoImage(file=\"../pictures/lightmode.png\")\n    toggle_color_button = Button(topframe,\n                                 image=[darkmode_image, lightmode_image][color_mode],\n                                 text=[\"Darkmode\", \"Lightmode\"][color_mode],\n                                 command=lambda: toggle_color_mode(containers),\n                                 compound=\"left\",\n                                 bd=0,\n                                 highlightbackground=\"#707070\"\n                                 )\n    toggle_color_button.grid(row=0, column=1, sticky=\"ew\", padx=10, pady=10)\n    \n    # global toggle_lang_button\n    # global de_flag\n    # global fr_flag\n    # global gb_flag\n    # de_flag = PhotoImage(file=\"../pictures/de.png\").subsample(3, 3)\n    # fr_flag = PhotoImage(file=\"../pictures/fr.png\")\n    # gb_flag = PhotoImage(file=\"../pictures/gb.png\")\n    \n    global lang_selection\n    lang_selection = StringVar()\n    toggle_lang_menu = OptionMenu(topframe,\n                                lang_selection,\n                                \"Deutsch\",\n                                \"Francais\",\n                                \"English\", command=toggle_lang)\n    toggle_lang_menu.grid(row=0, column=2, sticky=\"ew\", padx=30, pady=10)\n    \n    # Leftframe\n    leftframe = Frame(root, bg=lblue)\n    leftframe.place(y=0, x=0, relheight=1, relwidth=0.1)\n    \n    sep = Label(leftframe, bg=\"white\")\n    sep.place(x=0, rely=0.299, relwidth=1, height=3)\n    \n    global selectframe\n    selectframe = Frame(leftframe, bg=lblue)\n    selectframe.place(x=0, rely=0.305, relwidth=1, relheight=0.695)\n    \n    global buttons\n    buttons = selection_buttons(leftframe, \"select\", \"Analysis\", \"Algebra\", \"Numbers\")\n    \n    # Mittleframe\n    mittleframe = Frame(root)\n    mittleframe.place(rely=0.1, relx=0.1, relheight=0.8, relwidth=0.9)\n    \n    inputframe = Frame(mittleframe, highlightbackground=lblue, highlightcolor=\"green\", highlightthickness=2)\n    inputframe.place(relx=0.1, rely=0.2, relwidth=0.3, relheight=0.6)\n    \n    global inputentry\n    inputentry = Entry(inputframe, bd=0, highlightthickness=0, justify=\"center\")\n    inputentry.place(relx=0, rely=0, relwidth=1, relheight=0.3)\n    \n    global error_label\n    error_label = Label(inputframe, fg=\"red\")\n    error_label.place(x=0, rely=0.3, relwidth=1, relheight=0.1)\n    \n    latex_in = Label(inputframe)\n    latex_in.place(x=0, rely=0.4, relwidth=1, relheight=0.6)\n    \n    input_fig = Figure()\n    input_canvas = FigureCanvasTkAgg(input_fig, master=latex_in)\n    input_canvas.get_tk_widget().pack()\n    figures.append((input_fig, input_canvas))\n    \n    bttn = Button(mittleframe, text=\"=\", command=get_user_input, bd=0, highlightbackground=\"#707070\")\n    bttn.place(relx=0.45, rely=0.45, relwidth=0.1, relheight=0.1)\n    \n    outputframe = Frame(mittleframe, highlightbackground=lblue, highlightthickness=2)\n    outputframe.place(relx=0.6, rely=0.2, relwidth=0.3, relheight=0.6)\n    \n    global einstellungs_frame\n    einstellungs_frame = Frame(outputframe)\n    einstellungs_frame.place(x=0, y=0, relwidth=1, relheight=0.3)\n    \n    # global outlabel\n    # outlabel = Label(outputframe)\n    # outlabel.place(x=0, y=0, relwidth=1, relheight=0.3)\n    \n    latexout = Label(outputframe)\n    latexout.place(x=0, rely=0.4, relwidth=1, relheight=0.6)\n    \n    out_fig = Figure()\n    out_canvas = FigureCanvasTkAgg(out_fig, master=latexout)\n    out_canvas.get_tk_widget().pack(side=\"top\", fill=\"both\", expand=1)\n    figures.append((out_fig, out_canvas))\n    \n    # Bottomframe\n    bottomframe = Label(root)\n    bottomframe.place(relx=0.1, rely=0.9, relwidth=0.9, relheight=0.1)\n    \n    def exit_screen(event=None):\n        root.destroy()\n        print(f\"{memory_dict = }\")\n    \n    exitbutton = Button(bottomframe,\n                        text=[\"Schließen\", \"Fermer\", \"Exit\"][lang],\n                        command=exit_screen,\n                        bd=0,\n                        highlightthickness=1.5,\n                        highlightbackground=\"red\")\n    exitbutton.place(relx=0.85, rely=0.2, relwidth=0.1, relheight=0.6)\n    \n    containers = [topframe, logo, mittleframe, bottomframe, inputentry, inputframe, error_label, einstellungs_frame,\n                  bttn, toggle_color_button, toggle_lang_menu, exitbutton, latex_in, latexout, error_label]\n    \n    root.bind(\"<Return>\", get_user_input)\n    root.bind(\"<KP_Enter>\", exit_screen)\n    inputentry.focus()\n    root.mainloop()\n\n\nif __name__ == \"__main__\":\n    create_screen()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/main/WolframBeta.py b/main/WolframBeta.py
--- a/main/WolframBeta.py	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
+++ b/main/WolframBeta.py	(date 1639581405781)
@@ -76,7 +76,6 @@
     elif method == "simpson":
         return simpson(f, lower, upper)
 
-# Int_1^3(x^2)dx
 
 
 def interprete(f):
Index: .idea/WolframBeta.iml
===================================================================
diff --git a/.idea/WolframBeta.iml b/.idea/WolframBeta.iml
deleted file mode 100644
--- a/.idea/WolframBeta.iml	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
+++ /dev/null	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="PYTHON_MODULE" version="4">
-  <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$" />
-    <orderEntry type="jdk" jdkName="Python 3.8" jdkType="Python SDK" />
-    <orderEntry type="sourceFolder" forTests="false" />
-    <orderEntry type="module" module-name="Tests" />
-  </component>
-</module>
\ No newline at end of file
Index: .idea/.gitignore
===================================================================
diff --git a/.idea/.gitignore b/.idea/.gitignore
deleted file mode 100644
--- a/.idea/.gitignore	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
+++ /dev/null	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
@@ -1,3 +0,0 @@
-# Default ignored files
-/shelf/
-/workspace.xml
Index: .idea/modules.xml
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
deleted file mode 100644
--- a/.idea/modules.xml	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
+++ /dev/null	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
@@ -1,9 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/../Tests/.idea/Tests.iml" filepath="$PROJECT_DIR$/../Tests/.idea/Tests.iml" />
-      <module fileurl="file://$PROJECT_DIR$/.idea/WolframBeta.iml" filepath="$PROJECT_DIR$/.idea/WolframBeta.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
Index: .idea/misc.xml
===================================================================
diff --git a/.idea/misc.xml b/.idea/misc.xml
deleted file mode 100644
--- a/.idea/misc.xml	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
+++ /dev/null	(revision 0799ebe89f7c551c40fd9aae331bb61cd26faed8)
@@ -1,4 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectRootManager" version="2" project-jdk-name="Python 3.8" project-jdk-type="Python SDK" />
-</project>
\ No newline at end of file
