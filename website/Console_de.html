<!doctype html>
<html lang="fr">
   <head>
      <link rel=" stylesheet" media="screen" type="text/css" href="website.css" />
      <meta charset="utf-8">
      <title>Wolframbeta</title>
   </head>
   
   
   <body>
      <a href=Console_de.html><img  id="de" src="https://raw.githubusercontent.com/Feeeeeeeeeelix/WolframBeta/main/pictures/de.png" alt=""/></a>
      <a href="Console_fr.html"><img  id="fr" src="https://raw.githubusercontent.com/Feeeeeeeeeelix/WolframBeta/main/pictures/fr.png" alt=""/></a>
      <img  id="logo" src="https://raw.githubusercontent.com/Feeeeeeeeeelix/WolframBeta/main/pictures/logo.png" alt=""/>
      <img  id="ana3" src="ana3.png" style="top:50px;" alt=""/>
      <br/><br/><br/><br/>
      
      <a href="website_de.html" class="button" style="top:0px;">Home</a>
      <a href="Algebra_de.html" class="button" style="top:90px;">Rechner</a>
      <a href="Analysis_de.html" class="button" style="top:180px;">Analysis</a>
      <a href="Matrix_de.html" class="button" style="top:270px;">Matrizen</a>
      <a href="Modul_de.html" class="button" style="top:360px;">Console</a>
      
      <div>
         
         <h3> Was kann man mit unserem Code mchen?</h3>

         <p>
            Mir unsrem Code ist viel mehr möglich. Das schöne ist, hier kann man viel genauer arbeiten und Methoden wie for-Schleifen und if-Abfragen verwenden.
            Man kann zum Beispiel eine Folge an Polynomen definieren, zum Beispiel die Tschebbycheff Polynome, indem man eine Rekursive Folge berechnet.
            Für eine Folge von Funktionen könnte man ihre Integrale untersuchen, um mehr über die Folge zu lernen.
            Auch zufällige Ereignisse kann man gut untersuchen, zum Beispiel die durschnittliche Norm von Eigenwerten von Matrizen mit bestimmter Verteilung von Einträgen oder ähnliches betrachten.
            Für Konvergenzfragen und Stabilität kann man auf unser Programm zurückgreifen.
            Fragt man sich wie gut ein Algorithmus gegen eine Lösung konvergiert, so kann man mit unserem Programm die Lösung bestimmen und die Konvergenz untersuchen!
            Es gibt kaum Grenzen, weshalb sich das Arbeiten mit unserem Modul für eine Fortgeschrittene Arbeit sehr lohnt! 
         </p>
         
         <p>
            Für ein genaues Verständniss der Funktionen vom Modul kann man unseren Code lesen,
            jedoch empfiehlt sich diese Liste einfach durchzulesen/in dieser Liste nachzuschlagen.
         </p>
			
         
         <h4>Hier eine Liste unserer nützlichen Funktionen:</h4>
         
         <h3>Klassen:</h3>
         
		  <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
               <th>Beispiel</th>
            </tr>
            <tr>
               <td>Function(f(x))</td>
               <td>Definiert Funktionen</td>
               <td>f = Function("sin(x^2-1)")</td>
            </tr>
			<tr>
               <td>Polynom("a_n*x^n + ... + a_0")</td>
               <td>Definiert Polynom</td>
               <td>P = Polynom("x^4 -3x^2 -1x +2")</td>
            </tr>
			<tr>
               <td>Matrix([[a_11,...,a_1n],...,[a_n1,...,a_nn]])</td>
               <td>Definiert Matrizen</td>
               <td>A = Matrix([[1,2,3],[4,2,1],[0,0.1,18])</td>
            </tr>
         </table>
         
         <p>Jeder diese Klassen hat viele Funktionen. Man kann sie zum Beispiel ausschreiben: print(A).</p>
         
         <h3>Methoden für Funktionen:</h3>
         
         <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
               <th>Beispiel</th>
            </tr>
            <tr>
               <td>cos, arccos, cosh, arccosh,<br> sin, arcsin, sinh, arcsinh,<br> tan, arctan, tanh, arctanh</td>
               <td>Elementare trigonometrischen Funktionen</td>
               <td>cos(pi)</td>
            </tr>
            <tr>
               <td>exp(x) oder e^x</td>
               <td>Exponentialfunktion</td>
               <td>e^4</td>
            </tr>
            <tr>
               <td>sqrt(x) oder root(x, n)</td>
               <td>Wurzelfunktion</td>
               <td>sqrt(2), root(18, 5)</td>
            </tr>
            <tr>
               <td>ln(x)</td>
               <td>natürlicher Logarithmus</td>
               <td>ln(2)</td>
            </tr>
            <tr>
               <td>log(x, n)</td>
               <td>Logarithmus (Basis n) von x</td>
               <td>log(10, 2)</td>
            </tr>
            <tr>
               <td>min(f, a, b), max(f, a, b)</td>
               <td>Minimum/Maximum von f auf [a;b] bestimmen.<br>
				   Dabei kann f eine Instanz der class "Function" sein, oder ein string.</td>
               <td>min(sin^2(x) - cos(5*x), 0.5, 0.7)</td>
            </tr>
            <tr>
               <td>nullstellen(f, a, b), f=0</td>
               <td>Nullstellen von f auf [a;b] bestimmen.</td>
               <td>nullstelle(x^3-x*sin(x),0,2)</td>
            </tr>
            <tr>
               <td>Int(a, b, f(x), x)</td>
               <td>Integral von f über [a; b] bezüglich der Variable x.</td>
               <td>Int(3,4,ln(x)/x,x)</td>
            </tr>
            <tr>
               <td>d/dx(f(x))</td>
               <td>Ableitung von f(x).</td>
               <td>d/dx(sqrt(1-cos(x)^2))</td>
            </tr>
            <tr>
               <td>d^n/dx^n(f(x))</td>
               <td>Exakte n'te Ableitung von f(x).</td>
               <td>d^3/dx^3(ln(sin(x)^2 + 1))</td>
            </tr>
            <tr>
               <td>d^n/dx^n(f(x))(x_0)</td>
               <td>Approximative n'te Ableitung von f(x) in x_0.</td>
               <td>d^3/dx^3(sin(exp(x^2 - 4)))(5)</td>
            </tr>
         </table>
         
         <p>Hier ein Beispiel für die Anwendung dieser Klasse:</p>
         <p>Angenommen wir haben eine Physikalische Aufgabe bei der wir ein Integral berechnen müssen, dessen exakter Wert nicht bestimmt werden kann,
         da das Integral nicht elementar ist. Dann können wir dieses leicht berechnen.<p>
		 
		 <p>
		 Man könnte aber auch Differntialgleichungen lösen. Dafür die Funktion euler_collatz(f(t,y),t_0,y_0,t_ende). <br>
		 Für die DGL y' = 9.8*y^2 - sin(t*y) mit y(0)=3 wäre zum Beispiel y(1) gesucht. Dann wäre folgender Code nützlich:<br>
		 </p>
		 
		 <img src="DGL.png" style="margin-left:400px;" alt=""/>
		 
		 <p> Auch Folgen von Funktionen sollten leicht zu analysieren sein!</p>
		 
         <h3>Methoden für Polynome:</h3>
         
         <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
               <th>Beispiel</th>
            </tr>
			<tr>
               <td>+,-,*, ^n</td>
               <td>Elementare Operationen</td>
               <td>P = Q^2 - R^2,<br> wobei Q und R Instanzen der Klasse sind</td>
            </tr>
			<tr>
               <td>f.derivative()</td>
               <td>Exakte Ableitung</td>
               <td>P = Q.derivative()</td>
            </tr>
            <tr>
               <td>f.nullstellen()</td>
               <td>Approximative Nullstellen</td>
               <td>L = P.nullstellen()</td>
            </tr>
			<tr>
               <td>neville([[x_0,y_0],...,[x_n,y_n]]</td>
               <td>Findet Polynom durch gegebene Punkte</td>
               <td>P = neville([[1,3],[4,7],[6,-2],[7,1])</td>
            </tr>
         </table>
         
         <p>Hier ein Beispiel Programm um die ersten Tschebyscheff Funktionen rekursiv zu berechnen:</p>   
         
         
		 <img src="polynoms.png" style="margin-left:400px;" alt=""/>
       
       
         <h3>Methoden für Matrizen:</h3>
		  
		 <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
            </tr>
            <tr>
               <td>+, -, *, ^n</td>
               <td>Elementare Operatoren für Matrizen</td>
            </tr>
            <tr>
               <td>^-1 oder inverse</td>
               <td>Berechnet die Inverse von A</td>
            </tr>
            <tr>
               <td>^T</td>
               <td>Transponierte</td>
            </tr>
            <tr>
               <td>det</td>
               <td>Determinante</td>
            </tr>
            <tr>
               <td>Eigenvalues</td>
               <td>Berechnet alle komplexen Eigenwerte.<br>Dabei wird im symmetrischen Fall das Jacobi-Verfahren
                  verwendet.<br>Sonst wird A in Hessebergform transformiert um effiziente Givens-Rotationen im QR-Verfahren
                  zu machen. <br> Damit erhalten wir eine Block-Diagonal-Matrix, dessen 2x2 Blöcke die komplesen Eigenenwerte
                  bestimmt.
               </td>
            </tr>
			   <td>lu</td>
               <td>Berechnet, falls existent, die LU-Zerlegung: A = LU.<br> L ist eine normalisierte untere Dreiecksmatrix und U eine obere Dreiecksmatrix.</td>
            </tr>
            <tr>
               <td>QR</td>
               <td>Berechnet für beliebige Matrizen A = QR<br> Q ist eine orthogonale Matrix und R eine verallgemeinerte obere Dreiecksmatrix.</td>
            </tr>
            <tr>
               <td>cholesky</td>
               <td>Berechnet für symmetrische und positiv definite Matrizen A = L*L^T<br> L ist eine untere Dreiecksmatrix.</td>
            </tr>
            <tr>
               <td>lu_solve</td>
               <td> Löst LUx=b durch lösen von Ly=b und dann Ux=y.</td>
            </tr>
            <tr>
               <td>cholesky_solve</td>
               <td>Analog zu LU</td>
            </tr>
            <tr>
               <td>gauss_solve</td>
               <td>Durch elementare Zeilenumformungen wird A zur Id-Matrix umgeformt.<br> Diese Operationen werden auf b
                  anwgewendet um Ax=b zu lösen
               </td>
            </tr>
            <tr>
               <td>gauss_explanied</td>
               <td>Hier wird das Gauss-Verfahren sehr detailreich erklärt<br> und man sieht die Rechnungen beim lösen von Ax=b!
               </td>
            </tr>
            <tr>
               <td>ausgleichsproblem</td>
               <td>Falls Ax=b überbestimmt ist, gibt es keine Lösung.<br> Man kann aber ein x finden, welches die Norm von
                  Ax-b minimiert.<br> Dies kann für Interpolation in Physik nützlich sein.
               </td>
            </tr>
            
         </table>

         <p>
         Hier noch ein Beispiel für eine Funktion mit Matrizen. Falls ein probalistisches Problem durch diskrete Zeit n und Vektoren u_n mit u_(n+1)=A*u_n dargestellt werden kann, kann man nach dem Wert u_100 fragen. Per Hand wäre dies unmöglich, per Code aber nur wenige Zeilen lang:
         
         Bild:
         
         v = Matrix([[0.5,0.3,0.2]])  #u_0
         A = Matrix([[0.2,0.5,0],[0.6,0,0.2],[0.2,0.5,0.8]])
         for n in range(1,100):
			v = A*v 	#u_(n+1) = A * u_n
         print(v)
         
         </p>
         
           
         <br />
         <hr />
         
         <h4> Die Entwickler: &nbsp;&nbsp; Felix Dehon und Eric Trébuchon, aus der TSMP </h4>
      </div>
   </body>
</html>

