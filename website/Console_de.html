<!doctype html>
<html lang="fr">
   <head>
      <link rel=" stylesheet" media="screen" type="text/css" href="website.css" />
      <meta charset="utf-8">
      <title>WolframBeta</title>
   </head>
   
   
   <body>
      <div class="header">
      <img  id="logo" src="https://raw.githubusercontent.com/Feeeeeeeeeelix/WolframBeta/main/pictures/logo.png" alt=""/>
      </div>
      
      <a href=Console_de.html><img  id="de" src="https://raw.githubusercontent.com/Feeeeeeeeeelix/WolframBeta/main/pictures/de.png" alt=""/></a>
      <a href="Console_fr.html"><img  id="fr" src="https://raw.githubusercontent.com/Feeeeeeeeeelix/WolframBeta/main/pictures/fr.png" alt=""/></a>
      <img  id="ana3" src="ana3.png" style="top:50px;" alt=""/>
      <br/>
      
      <a href="Main_de.html" class="button" style="top:0px;">Home</a>
      <a href="Algebra_de.html" class="button" style="top:90px;">Rechner</a>
      <a href="Analysis_de.html" class="button" style="top:180px;">Analysis</a>
      <a href="Matrix_de.html" class="button" style="top:270px;">Matrizen</a>
      <a href="Console_de.html" class="button" style="top:360px;">Console</a>
      
      <div>
         
         <h3> Was kann man mit unserem Code machen?</h3>

         <p>
            Mir unsrem Code ist viel mehr möglich. Das schöne ist, hier kann man viel genauer arbeiten und Methoden wie for-Schleifen und if-Abfragen verwenden.
            Man kann zum Beispiel eine Folge an Polynomen definieren, zum Beispiel die Tschebbycheff Polynome, indem man eine Rekursive Folge berechnet.
            Für eine Folge von Funktionen könnte man ihre Integrale untersuchen, um mehr über die Folge zu lernen.
            Auch zufällige Ereignisse kann man gut untersuchen, zum Beispiel die durschnittliche Norm von Eigenwerten von Matrizen mit bestimmter Verteilung von Einträgen oder ähnliches betrachten.
            Für Konvergenzfragen und Stabilität kann man auf unser Programm zurückgreifen.
            Fragt man sich wie gut ein Algorithmus gegen eine Lösung konvergiert, so kann man mit unserem Programm die Lösung bestimmen und die Konvergenz untersuchen!
            Es gibt kaum Grenzen, weshalb sich das Arbeiten mit unserem Modul für eine fortgeschrittene Arbeit sehr lohnt!
         </p>
         
         <p>
            Für ein genaues Verständnis der Funktionen vom Modul kann man unseren Code lesen,
            jedoch empfiehlt sich diese Liste einfach durchzulesen/in dieser Liste nachzuschlagen.
         </p>
			
         
         <h4>Hier eine Liste unserer nützlichen Funktionen:</h4>
         
         <h3>Klassen:</h3>
         
		  <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
               <th>Beispiel</th>
            </tr>
            <tr>
               <td>Function(f(x))</td>
               <td>Definiert Funktionen</td>
               <td>f = Function("sin(x^2-1)")</td>
            </tr>
			<tr>
               <td>Polynom("a_n*x^n + ... + a_0")</td>
               <td>Definiert Polynom</td>
               <td>P = Polynom("x^4 -3x^2 -1x +2")</td>
            </tr>
			<tr>
               <td>Matrix([[a_11,...,a_1n],...,[a_n1,...,a_nn]])</td>
               <td>Definiert Matrizen</td>
               <td>A = Matrix([[1,2,3],[4,2,1],[0,0.1,18])</td>
            </tr>
         </table>
         
         <p>Jeder diese Klassen hat viele Funktionen. Man kann sie zum Beispiel ausschreiben: print(A).</p>
         
         <h3>Methoden für Funktionen:</h3>
         
         <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
               <th>Beispiel</th>
            </tr>
            <tr>
               <td>cos, arccos, cosh, arccosh,<br> sin, arcsin, sinh, arcsinh,<br> tan, arctan, tanh, arctanh</td>
               <td>Elementare trigonometrischen Funktionen</td>
               <td>cos(pi)</td>
            </tr>
            <tr>
               <td>exp(x) oder e^x</td>
               <td>Exponentialfunktion</td>
               <td>e^4</td>
            </tr>
            <tr>
               <td>sqrt(x) oder root(x, n)</td>
               <td>Wurzelfunktion</td>
               <td>sqrt(2), root(18, 5)</td>
            </tr>
            <tr>
               <td>ln(x)</td>
               <td>natürlicher Logarithmus</td>
               <td>ln(2)</td>
            </tr>
            <tr>
               <td>log(x, n)</td>
               <td>Logarithmus (Basis n) von x</td>
               <td>log(10, 2)</td>
            </tr>
            <tr>
               <td>min(f, a, b), max(f, a, b)</td>
               <td>Minimum/Maximum von f auf [a;b] bestimmen.<br>
				   Dabei kann f eine Instanz der class "Function" sein, oder ein string.</td>
               <td>min(sin^2(x) - cos(5*x), 0.5, 0.7)</td>
            </tr>
            <tr>
               <td>nullstellen(f, a, b)</td>
               <td>Nullstellen von f auf [a; b] bestimmen.</td>
               <td>nullstellen(x^3-x*sin(x),0,2)</td>
            </tr>
            <tr>
               <td>riemann(a, b, f(x), x), <br />trapez(a, b, f(x), x)<br/> oder simpson(a, b, f(x), x)</td>
               <td>Integral von f über [a; b] bezüglich der Variable x.</td>
               <td>trapez(3,4,ln(x)/x,x)</td>
            </tr>
			<tr>
               <td>trapez_fehler(a, b, f(x), x),<br/> simpson_fehler(a, b, f(x), x)</td>
               <td>Obere Schranke für Fehler für das Integral von f.</td>
               <td>trapez_fehler(3,4,ln(x)/x,x)</td>
            </tr>
            <tr>
               <td>f.diff()</td>
               <td>Ableitung von f(x).</td>
               <td>df = Function("cos(sin(x)^2-1)*x").diff()</td>
            </tr>
            <tr>
               <td>d^n/dx^n(f(x))</td>
               <td>Exakte n'te Ableitung von f(x)</td>
               <td>d^3/dx^3(ln(sin(x)^2 + 1))</td>
            </tr>
            <tr>
               <td>der(f, var="x", n=1, dx=10 ** (-3))</td>
               <td>Approximative n-te Ableitung von f(x) in x_0.</td>
               <td>der(f,x,n=3)(5)</td>
            </tr>
         </table>
         
         <p>Hier ein Beispiel für die Anwendung dieser Klasse:</p>
         <p>Angenommen wir haben eine Physikalische Aufgabe bei der wir ein Integral berechnen müssen, dessen exakter Wert nicht bestimmt werden kann,
         da das Integral nicht elementar ist. Dann können wir dieses leicht berechnen.<p>
		 
		 <p>
		 Man könnte aber auch Differntialgleichungen lösen. Dafür die Funktion euler_collatz(f(t,y),t_0,y_0,t_ende). <br>
		 Für die DGL y' = 9.8*y^2 - sin(t*y) mit y(0)=3 wäre zum Beispiel y(1) gesucht. Dann wäre folgender Code nützlich:<br>
		 </p>
		 
		 <img src="screens/DGL.png" style="margin-left:300px;width:50%;height:auto;" alt=""/>
		 
		 <p> Auch Folgen von Funktionen sollten leicht zu analysieren sein!</p>
		 
         <h3>Methoden für Polynome:</h3>
         
         <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
               <th>Beispiel</th>
            </tr>
			<tr>
               <td>+,-,*, ^n</td>
               <td>Elementare Operationen</td>
               <td>P = Q^2 - R^2,<br> wobei Q und R Instanzen der Klasse sind</td>
            </tr>
			<tr>
               <td>P[i]</td>
               <td>i-ter Koeffizient</td>
               <td>P[3]</td>
            </tr>
			<tr>
               <td>P.derivative()</td>
               <td>Exakte Ableitung</td>
               <td>P = Q.derivative()</td>
            </tr>
            <tr>
               <td>P.nullstellen()</td>
               <td>Approximative Nullstellen</td>
               <td>L = P.nullstellen()</td>
            </tr>
			<tr>
               <td>neville([[x_0,y_0],...,[x_n,y_n]])</td>
               <td>Findet Polynom durch gegebene Punkte</td>
               <td>P = neville([[1,3],[4,7],[6,-2],[7,1]])</td>
            </tr>
         </table>
         
         <p>Hier ein Beispiel Programm um die ersten Tschebyscheff Funktionen rekursiv zu berechnen:</p>   
         
         
		 <img src="screens/polynom.png" style="margin-left:350px;width:40%;height:auto;" alt=""/>
       
       
         <h3>Methoden für Matrizen:</h3>
		  
		 <table>
            <tr>
               <th>Ausdruck</th>
               <th>Funktion</th>
            </tr>
            <tr>
               <td>+, -, *, ^n</td>
               <td>Elementare Operatoren für Matrizen</td>
            </tr>
			<tr>
               <td>A[i][j]</td>
               <td>Der (i,j)-Eintrag <td>
            </tr>
            <tr>
               <td>A.inverse()</td>
               <td>Berechnet die Inverse von A</td>
            </tr>
            <tr>
               <td>A.T()</td>
               <td>Transponierte von A</td>
            </tr>
            <tr>
               <td>A.det()</td>
               <td>Determinante von A</td>
            </tr>
            <tr>
               <td>A.eigenvalues()</td>
               <td>Berechnet alle komplexen Eigenwerte.<br>Dabei wird im symmetrischen Fall das Jacobi-Verfahren
                  verwendet.<br>Sonst wird A in Hessebergform transformiert um effiziente Givens-Rotationen im QR-Verfahren
                  zu machen. <br> Damit erhalten wir eine Block-Diagonal-Matrix, dessen 2x2 Blöcke die komplesen Eigenenwerte
                  bestimmt.
               </td>
            </tr>
			<tr>
               <td>Random(m, n, low=0, high=10):</td>
               <td>Eine Zufällige mxn Marix mit ganzen Einträgen von low bis high.</td>
            </tr>
			<tr>
               <td>RandomSym(m, low=0, high=10):</td>
               <td>Eine Zufällige symmetrische mxm Marix mit ganzen Einträgen von low bis high.</td>
            </tr>
			<tr>
               <td>Zero(m,n) <br> Id(n) </td>
               <td>Nullmatrix oder Identitäts-matrix</td>
            </tr>            
			<tr>
               <td>A.normS()<br> A.normZ()</td>
               <td>Bestimmt die "Zeilensummennorm" oder "Spaltensummennorm"</td>
            </tr>
            <tr>
			   <td>A.lu()</td>
               <td>Berechnet, falls existent, die LU-Zerlegung: A = LU.<br> L ist eine normalisierte untere Dreiecksmatrix und U eine obere Dreiecksmatrix.</td>
            </tr>
            
            <tr>
               <td>A.QR()</td>
               <td>Berechnet für beliebige Matrizen A = QR<br> Q ist eine orthogonale Matrix und R eine verallgemeinerte obere Dreiecksmatrix.</td>
            </tr>
            <tr>
               <td>A.cholesky()</td>
               <td>Berechnet für symmetrische und positiv definite Matrizen A = L*L^T<br> L ist eine untere Dreiecksmatrix.</td>
            </tr>
            <tr>
               <td>A.lu_solve(b)</td>
               <td>Löst LUx=b durch lösen von Ly=b und dann Ux=y.</td>
            </tr>
            <tr>
               <td>A.cholesky_solve(b)</td>
               <td>Analog zu LU</td>
            </tr>
            <tr>
               <td>A.gauss_solve(b)</td>
               <td>Durch elementare Zeilenumformungen wird A zur Id-Matrix umgeformt.<br> Diese Operationen werden auf b
                  anwgewendet um Ax=b zu lösen
               </td>
            </tr>
            <tr>
               <td>A.gauss_explained(b)</td>
               <td>Hier wird das Gauss-Verfahren sehr detailreich erklärt<br> und man sieht die Rechnungen beim lösen von Ax=b!
               </td>
            </tr>
            <tr>
               <td>A.ausgleichsproblem(b)</td>
               <td>Falls Ax=b überbestimmt ist, gibt es keine Lösung.<br> Man kann aber ein x finden, welches die Norm von
                  Ax-b minimiert.<br> Dies kann für Interpolation in Physik nützlich sein.
               </td>
            </tr>
            <tr>
               <td>A.power_method()</td>
               <td>Bestimmt, falls A reell diagonaliserbar ist, den Eigenwert mit größter Norm.</td>
            </tr>
			<tr>
               <td>A.latex()</td>
               <td>Gibt den Latex-Code für die Darstellung von A.</td>
            </tr>
			<tr>
               <td>A.sub_matrix(ymin, ymax, xmin, xmax)</td>
               <td>Gibt eine gegebene Teilmatrix von A.</td>
            </tr>
            
         </table>

         <p>
            Hier noch ein Beispiel für eine Funktion mit Matrizen. Falls ein probalistisches Problem durch diskrete
            Zeit n und Vektoren u_n mit u_(n+1)=A*u_n dargestellt werden kann, kann man nach dem Wert u_100 fragen.
            Per Hand wäre dies unmöglich, per Code aber nur wenige Zeilen lang:
         </p>

         <img src="screens/matrix.png" style="margin-left:350px;width:50%;height:auto;" alt=""/>
         <br />
         <br />
      </div>
   </body>
</html>

